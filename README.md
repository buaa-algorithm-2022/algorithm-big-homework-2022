# algorithm-big-homework-2022

算法大作业的代码仓库。

## 小组成员
张梁，边俊林，杨小梅

## 小组命名
WA自动机队


# 一、作业要求
**《程序设计与算法》大作业**

大家根据自己的兴趣和知识熟悉程度，进行大作业选题，并按照下面的要求完成。

【选题清单】
（1）【排序算法：选择排序，归并排序，快速排序，希尔排序，基数排序】，对所有算法进行分析并实现，分析其在不同规模的输入下单机性能变化情况；同时实现对于以下两种输入的排序:  
①对数值的范围在[{-10}^{100},{10}^{100}]的数组排序，此项任务只能使用C或C++完成。  
②利用多线程实现大规模数据的分布式排序，输入超过100万为最低大规模要求。  
（2）【图算法：PageRank，子图匹配】，尝试选择一种图算法进行复杂度分析并实现，分析其在不同规模的图问题上的性能变化情况；同时调研其分布式实现的框架和性能。  
（3）【智能算法：模拟退火，遗传算法，蚁群算法，禁忌搜索】，尝试选择两种智能算法进行分析并实现，分析其算法复杂度受影响的可能因素，分析其至少在两种特定问题中解决的优劣势。  
（4）【机器学习算法：xgboost，支持向量机，随机森林，卷积神经网络】，尝试选择一种机器学习算法进行分析并实现（深度学习方法不能使用框架），分析其算法复杂度受影响的可能因素，并思考与传统算法分析的异同。

以上题目实现，如无特殊说明不限制代码语言的选择。要求用github/gitee对代码进行管理，需要写readme.md文件作为完成大作业的一部分。


【组队要求】
每队限制3名学生，自行商定一名组长，并明确各自分工。
请将组队信息填报到在线文档中：
https://docs.qq.com/sheet/DWU1tSU9JZGlzdEFE?tab=BB08J2


【提交要求】
提交时请提交“**代码+报告(readme转换为PDF)+答辩ppt**”的压缩文件，并附上代码的仓库连接。命名为“组长学号_队伍名_大作业”，如“ZF1234567_北航队_大作业.zip”。  
提交地址：https://bhpan.buaa.edu.cn:443/link/63102068A3BE541D9A7A8C577CA1B04D  
（访问密码：H5oW）。  
最晚提交时间：11月14日（最后一次课前）  

## 说明
排序算法中的要求（1）需要所有排序算法全部实现。要求（2）分布式尽量实现。  
提醒一下，这两个要求不需要同时满足，分类讨论即可。  

## 备选题目
1、排序算法  
2、随机森林 https://www.jianshu.com/p/fdcda700d135  
3、卷积神经网络  

# 二、技术文档
## Git
https://www.runoob.com/git/git-basic-operations.html
### 常用命令
|命令                |说明|
|:-------------------|:----------|
|git pull            |拉取当前分支的远程代码 |
|git pull origin main|从远程main分支拉取代码到当前分支|
|git add .           |将当前文件夹下的所有更改提交到暂存区  |
|git commit -m ''    |提交暂存区到本地仓库。|
|git push            |将当前分支代码上传远程并合并|
|git diff            |比较文件的不同，即暂存区和工作区的差异。   |
|git branch -a       |列出所有分支|
|git branch test     |创建分支    |
|git checkout test   |切换分支    |

### 代码提交规范
每个人创建自己的分支。修改都是基于自己的分支，修改完成后提交merge请求，代码审核通过后merge到main分支。

## C++项目
除分布式模块外，算法实现、工程化结构、单线程/多线程运行部分使用C++编写。<br>
为了便于独立测试每个函数及合并进行性能测试，项目使用CMake构建，以支持多个main函数的配置。

### 工程结构
```
src
├── algo    // 算法实现
├── utils   // 工具类
│   │── Random.cpp      // 随机数生成
│   │── BigInteger.cpp  // 大数实现
│   │── Validation.cpp  // 正确性验证及部分重载方法
│   └── DataGenerator.cpp  // IO操作Utils 
├── Runner.cpp     // 程序入口 (单线程、多线程、性能测试)
└── CMakeLists.txt // 编译配置
```
为了便于统一执行算法，项目面向协议开发，算法实现请继承于`Sortable`协议
```c++
class Sortable {
public:
    virtual void sort(std::vector<BigInteger>& arr) = 0;
    virtual std::string toName() const = 0;
};
```

### 参数配置
C++工程支持以下两种模式，以命令行执行为例，IDE同理
- 无参数时，默认执行单线程/多线程性能测试
`./Runner`
- 指定数据集、算法及线程数（主要用于分布式场景执行子任务） 
`./Runner {数据集路径} {输出路径} {执行算法} {线程数}`<br>eg: `./Runner input.txt output.txt QuickSort 10`

### 编译
#### IDE (以Clion为例)
当修改文件后，右键`CMakeLists.txt`，选择"Reload CMake Project"即可完成文件同步<br>
编译、运行、Debug等操作直接使用IDE自带选项
#### Shell
> 首先确保已经安装CMake并配置到命令行中
```c++
cd C++      // 切换到CMake同级目录
cmake .     // 根据CMakeLists.txt生成Makefile
make        // 根据Makefile进行编译
```
完成后目录将会生成对应可执行文件（默认为`Runner`）

# 三、作业选题调研
## 1、排序算法调研
（1）【排序算法：选择排序，归并排序，快速排序，希尔排序，基数排序】，对所有算法进行分析并实现，分析其在不同规模的输入下单机性能变化情况；同时实现对于以下两种输入的排序:
①对数值的范围在[{-10}^{100},{10}^{100}]的数组排序，此项任务只能使用C或C++完成。
②利用多线程实现大规模数据的分布式排序，输入超过100万为最低大规模要求。

### 语言选择
由于大整数排序部分只能使用c或c++完成，c++提供了丰富的公共库，所以排序算法的实现统一使用C++比较好。

### 大整数排序
定义为class/struct，通过传入的string初始化。
实现compare方法。

有两种实现：  
1、通过string类型实现，每个字符代表一个位上的数字。  
2、通过int数组实现，进制为int类型可表示的最大十进制整数。  
   这样做的好处是可以直接截取输入string的固定位数生成。  

2更节省空间，但是计算复杂度稍高。

### 多线程实现大规模数据分布式排序
https://blog.csdn.net/qq_36622751/article/details/124807254

## 2、随机森林调研

#### 优点：1）有现成代码（python底层源码），在此基础上上进行优化；2）python有很多封装好的包，可以使用，可以做的很简单，也可以很复杂
#### 难点：1）算法原理细节需要搞懂，涉及到数学知识；2）需要进行算法分析

### 具体源码

随机森林 https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/ensemble/_forest.py

决策树 （随机森林是由决策树集成）https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/tree/_classes.py

### 源码参数解读：
https://blog.csdn.net/ys676623/article/details/78111196

## 最终选题
综合时间和小组成员的意向，最终决定选择排序算法作为最终题目。

## 时间安排
- 调研选题：2022年11月3日  
- 代码开发：
  - 算法实现：2022年11月4日\~2022年11月8日，4天
  - 多线程实现：2022年11月9日\~2022年11月13日，5天
  - 分布式实现：2022年11月14日\~2022年11月18日，5天
- ppt准备：2022年11月19日\~2022年11月21日，3天  
- 课程答辩：2022年11月22日

## 分工
张梁：项目创建、希尔排序，随机数生成，分布式实现
边俊林：基数排序，大数运算，程序框架，多线程实现
杨小梅：选择排序、归并排序、快速排序算法实现，PPT制作
共同参与部分：readme.md文件编写

# 四、排序算法实现

## 4.1 选择排序分析
1、核心思想  
   第i趟排序从序列的后n-i+1（i=1,2,...,n-1)个元素中选择一个值最小的元素与该n-i+1元素的最前面的那个元素交换位置，即与整个序列的第i个位置上的元素交换位置。  
2、时间复杂度  
   对具体n个元素的序列采用选择排序法，要经过n-1趟排序。  
   移动次数：元素移动的次数最少为0次（当原始序列为升序时），最多为3（n-1）次（当原始序列为降序时，3是第i趟排序中，值最小元素与未排序的第一个元素交换位置的次数，即代码中交换arr[i]与arr[d]的执行次数）  
   比较次数：无论序列中元素的初始排列状态如何，第i趟排序要找出值最小元素都需要经过n-i次元素之间的比较。因此，整个排序过程中元素之间的比较总次数为n (n - 1）/ 2 。  
   因此，算法的时间复杂度为O（n2）。  
   这个算法的执行效率当n相对小的时候，效率比较快，但是n一旦扩大，效率将会下降明显。  
3、空间复杂度  
   值最小元素与未排序的第一个元素交换位置时需要设置一个临时辅助空间，空间复杂度为O（1）。  
4、稳定性  
   由于值最小元素与未排好序的元素中第1个元素的交换动作是在不相邻的元素之间进行的，因而很有可能会改变值相同元素的前后位置，因此选择排序法是一种不稳定的排序方法。  

## 4.2 归并排序分析
1、核心思想  
   1）将整个待排序序列划分成多个不可再分的子序列，每个子序列中仅有 1 个元素；  
   2）所有的子序列进行两两合并，合并过程中完成排序操作，最终合并得到的新序列就是有序序列。  
2、时间复杂度  
   设n为待排序数组中的元素个数，T(n)为算法需要的时间复杂度，则  
   <img src=./data/T1.png width=30% />  
   其中C(n)是将两个含有n/2个数据元素的序列合并为一个含有n个数据元素的序列所需要的比较操作次数。  
   1） 最优时间复杂度分析:  
由对合并操作的最优时间复杂度分析我们知道，当刚好一个序列的最后一个值是另一个序列的最小值时， C(n)=n/2。  
   <img src=./data/T2.png width=30% />  
   2）最坏时间复杂度分析  
   由对合并操作的最坏时间复杂度分析我们知道，当两个序列各个元素的大小交叉排列时， C(n)=n-1。  
   <img src=./data/T3.png width=40% />  
   <img src=./data/T4.png width=30% />  
   综上:2路归并排序的最优时间复杂度和最坏时间复杂度均为$O(log_{2}n)$。  
3、空间复杂度  
   由于该算法需要用到与参加排序的序列同样大小的辅助空间，算法的空间复杂度为O（n）。  
4、稳定性  
   归并排序是一种稳定的排序算法，因为在两个有序子序列的归并过程中，若2个按值有序序列中出现相同元素，merge算法能够使前一个序列中那个相同元素先被复制，从而确保这两个相同元素的相对次序不发生改变。  
   
## 4.3 快速排序分析
1、核心思想  
在待排序元素中选择一个基准，经过一趟排序后把元素分为小于基准元素和大于等于基准元素的两部分。然后递归的对两个子表重复上述过程，直到每个部分中只有一个元素或者为空为止。  
2、空间复杂度  
由于快速排序是递归的，需要借助递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致。最好情况下为$O(log_{2}n)$；最坏情况下，因为要进行n-1次递归，所以栈深度为$O(n)$；平均情况下栈的深度为$O(log_{2}n)$。  
3、时间复杂度  
快速排序的实现使用了前后指针法，一趟排序从头尾交替搜索，直到low，hight重合，因此单趟的时间复杂度为O(n)，整个快速排序的时间复杂度与划分的趟数有关。理想情况下每次都从可以从中间划分为左右两个基本相等的两部分，共经过$log_{2}n$趟排序，最高情况下的时间复杂度为$O(log_{2}n)$。  最坏情况下，每次都将剩下的部分划分到同一侧，此时排序的趟数为n，排序的时间复杂度为$O(n^2)$。  
4、稳定性  
在划分算法中，若右端区域中有两个元素相同，且小于基准值的记录，则在交换到区间左侧之后，他们的相对位置会发生变化，所以快速排序是一种不稳定的排序。

## 4.4 希尔排序分析
1、核心思想  
先将待排序序列表分割成若干形如L[i, i + d, i + 2d, ... , i + kd]的“特殊”子表，即把相隔固定距离的元素组成一个子表，对各个子表分别进行直接插入排序，然后不断缩小间隔的距离，当整个表的元素已基本有序时，再对全体记录进行一次直接插入排序。  
2、空间复杂度  
由于希尔排序使用了常数个辅助单元，空间复杂度为O(1)。  
3、时间复杂度  
由于希尔排序的时间复杂度依赖增量排序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度为$O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为$O(n^2)$  
4、稳定性  
当相同关键字的记录被划分到不同的子表时，可能会改变他们之间的相对次序，因此希尔排序是一种不稳定的排序算法。

## 4.5 基数排序分析
1、核心思想  
- 首先按照位数从小到大(个、十、百、千、万)进行分配，依次将数据分配到对应的桶中，每次分配完成后按数值从小到大的顺序从桶中依次取出元素重新拼接成数组
- 由于数值范围为`[1e-100, 1e100]`，为了使基数排序支持负数，故分配19个桶，使用第0~19桶分别存放该位为-9~9的数
算法的描述如下  
```c++
RadixSort(arr,size)
   1. find max of input array arr. 
   2. find number of digits d in max. 
   3. for i = 1 to d
       3.1 sort the array elements according to ith place digits using CountingSort.

CountingSort(array, sizeOfArr, place)
   1. k --> the size of count array, size=19 is our case (storing [-9, 9])
   2. initialize count array with all elements as zeros.
   3. for i = 0 to (size-1)
       3.1 find the total count of each unique digit in dth place of elements and store the count at ith index in the count array.
   4. for i = 0 to k
       4.1 find the cumulative sum and store it in count array itself. 
   5. for j = (size-1) to 1
       5.1 store the elements from input array to output array using index from count array.
       5.2 decrease count of each element stored by 1.
```
2、时间复杂度
令n为输入数组中元素的数量，k为所有数字第i位（个、十、百、千、万）的最大值，在本算法中即k=19（用于支持负数排序，存放[-9,9]），d为所有元素中位数最多数字的位数。
由上述过程图，我们可以知道
- 计数排序的时间复杂度为O(n+k)
- 基数排序中循环调用了d次计数排序，故时间复杂度为O(d(n+k))

综上，算法总时间复杂度为O(d(n+k)))

3、空间复杂度  
如过程所示，在技术排序中，我们需要开辟O(k)的空间用于计数，同时O(n)的空间用于存放临时数组。

故算法总空间复杂度为O(n+k)
  
4、稳定性分析  
基数排序是一种稳定的排序算法，因为其将数据分配到桶中的遍历过程是按照原数组顺序的，所以对于将要放入同一个桶中的数据位置较前，从而确保这两个相同元素的相对次序不发生改变。

## 4.6 性能分析
### 4.6.1 单线程
|排序类型|线程数|数据规模|时间|
|:----------|:----------|:----------|:----------|
|选择排序|1|1万|8813ms|
|归并排序|1|1万|40ms|
|快速排序|1|1万|52ms|
|希尔排序|1|1万|74ms|
|基数排序|1|1万|400ms|
|选择排序|1|10万|917320ms|
|归并排序|1|10万|640ms|
|快速排序|1|10万|730ms|
|希尔排序|1|10万|1303ms|
|基数排序|1|10万|6084ms|

### 4.6.2 多线程
|排序类型|线程数|数据规模|时间|
|:----------|:----------|:----------|:----------|
|选择排序|8|1万|269ms|
|归并排序|8|1万|40ms|
|快速排序|8|1万|29ms|
|希尔排序|8|1万|33ms|
|基数排序|8|1万|124ms|
|选择排序|8|10万|31946ms|
|归并排序|8|10万|355ms|
|快速排序|8|10万|345ms|
|希尔排序|8|10万|432ms|
|基数排序|8|10万|1530ms|

### 4.6.3 分布式
|排序类型|节点数|总线程数|数据规模|时间|
|:----------|:----------|:----------|:----------|:----------|
|选择排序|2|8|100万|2953575ms|
|归并排序|2|8|100万|27233ms|
|快速排序|2|8|100万|27244ms|
|希尔排序|2|8|100万|29940ms|
|基数排序|2|8|100万|42044ms|

## 4.7 随机数生成实现
由于大整数的位数比较多，采用生成随机数对2取余来生成符号位，然后对新生成随机数对10000取余，从高位到低位，每次4位，共25次的方式来生成100位数字部分。

## 4.8 大整数实现
大数的数据结构采用字符串存储数值的绝对值部分，同时使用布尔值存储数值的正负性。
考虑到实际运算中不应存在正0负0，0在存储时正负性永远视为正。

并实现大数间的比较、重载大数输入输出、基于大数生成随机数等操作。部分比较逻辑如下：

```c++
bool operator == (const BigInteger& lhs, const BigInteger& rhs) {
    if (lhs.m_content == "0" && rhs.m_content == "0")
        return true;
    return lhs.m_content == rhs.m_content && lhs.isNegative() == rhs.isNegative();
}

bool operator < (const BigInteger& lhs, const BigInteger& rhs) {
    if (lhs == rhs) return false;
    if (lhs.m_content.size() == rhs.m_content.size()) {
        if (lhs.isNegative() && rhs.isNegative())
            return lhs.m_content > rhs.m_content;
        else if (!lhs.isNegative() && !rhs.isNegative())
            return lhs.m_content < rhs.m_content;
        return lhs.isNegative();
    } else if (lhs.isNegative() && rhs.isNegative()) {
        return lhs.m_content.size() > rhs.m_content.size();
    } else if (!lhs.isNegative() && !rhs.isNegative()) {
        return lhs.m_content.size() < rhs.m_content.size();
    } else {
        return lhs.isNegative();
    }
}

bool operator > (const BigInteger& lhs, const BigInteger& rhs) {
    return operator<(rhs, lhs);
}
```

## 4.9 多线程实现
### 4.9.1 执行流程
<img src=./data/multi_thread.jpg width=50% />

多线程的实现基于分治，对待排序数组划分不同区域，每个区域使用一个线程排序，最终使用归并排序合并结果。
### 4.9.2 目录结构
```
C++
├── CMakeLists.txt
└── src
    ├── Generate.cpp
    ├── Runner.cpp
    ├── algo
    │   ├── BubbleSort.cpp
    │   ├── MergeSort.cpp
    │   ├── QuickSort.cpp
    │   ├── RadixSort.cpp
    │   ├── SelectionSort.cpp
    │   └── ShellSort.cpp
    └── utils
        ├── BigInteger.h
        ├── DataGenerator.h
        ├── Random.h
        ├── Sortable.h
        └── Validation.h
```
多线程部分的代码使用了面向对象的思想，将每个排序算法继承Sortable父类，并实现sort方法来，使排序类型可以基于参数选择。

## 4.10 分布式实现
### 4.10.1 分布式结构
<img src=./data/distributed_architecture.jpg width=70% />

分布式部分使用Java语言实现。代码中使用了通信框架Netty来建立TCP连接传送文件。
### 4.10.2 程序执行流程
1、首先启动Master，Master节点会生成slave.amount份配置文件。然后启动slave.amount个TCP Server向slave发送文件。  
2、当master的Server启动后，依次启动slave节点。slave与master的相应端口建立连接，接收文件。  
3、slave调用命令行工具执行C++编译的多线程排序文件进行排序。  
4、slave将排好序的文件发送给master。  
5、master收到所有slave排序完成的文件后进行文件的merge，最终生成结果文件。  

#### 4.10.2.1 master
执行日志
```
执行命令：./generate bigint ./data/send/file0.txt 500000
执行命令：./generate bigint ./data/send/file1.txt 500000
执行完成：./generate bigint ./data/send/file0.txt 500000
Server for slave0 start...
执行完成：./generate bigint ./data/send/file1.txt 500000
Server for slave1 start...
Server建立连接：/127.0.0.1:62671
开始发送文件：./data/send/file0.txt
Server建立连接：/127.0.0.1:62679
开始发送文件：./data/send/file1.txt
文件发送结束：./data/send/file1.txt
发送over
文件发送结束：./data/send/file0.txt
发送over
Server断开连接：/127.0.0.1:62679
Server for slave1 close...
开始从127.0.0.1:8082接收文件： ./data/receive/slave1.txt...
Client建立连接：/127.0.0.1:8082
写文件：./data/receive/slave1.txt
Server断开连接：/127.0.0.1:62671
Server for slave0 close...
开始从127.0.0.1:8081接收文件： ./data/receive/slave0.txt...
Client建立连接：/127.0.0.1:8081
写文件：./data/receive/slave0.txt
写文件结束： ./data/receive/slave1.txt
Client断开连接: /127.0.0.1:8082
完成接收文件：./data/receive/slave1.txt
写文件结束： ./data/receive/slave0.txt
Client断开连接: /127.0.0.1:8081
完成接收文件：./data/receive/slave0.txt
BufferedReader add: ./data/receive/slave0.txt
BufferedReader add: ./data/receive/slave1.txt
文件merge开始...
文件merge结束...
程序用时：33698ms...
```

结果文件
```
-9999539987041744849471467124833727926741576613196160623043045674892853683817253184302040477042433650
-9999529570811718921731412260328048908997679784608504245014077744742456841552549161792677318672782191
-9998891789754927587873763939133832908943894395821478542929569046846435746219986450307709817313878518
-9998719856969091763391284150691390331622663143997330385755626480979236019314666230797164171656489883
-9998211382558841423769448076290564059210969372282952886037898124372426956198527418298763181842293771
-9998183474234380117894796514797453594223794144527483187399476168539335746957792233589784800676935209
-9997664471336162490184101697201950459874668371639742357352757368427316468445363442448358585761007999
-9997213227615424400693288586105910097021930990669123353355054773511045087688939182524960918033253438
-9997115258498567686577029270386792455885400440122100574461286508252816255430395790726912948039009296
-9996860115182332520792748630241550486689623354556855574836303607921056427214795829018223851792622312
...
9999459674546549508124878853496420271473125240862724406873522703950192426270703697961948508591845630
9999623834249099941066974090890933891106643750217096809084822386555647414189344926394667498199799424
9999936731149501119753462444867274409151314153349020686649977384297984274535984111238568727746685510
```

#### 4.10.2.2 slave0
执行日志
```
slave.name=slave0
Client建立连接：/127.0.0.1:8881
写文件：./data/receive/file0.txt
写文件结束： ./data/receive/file0.txt
执行命令：./Runner ./data/receive/file0.txt ./data/send/slave0.txt QuickSort 4
执行完成：./Runner ./data/receive/file0.txt ./data/send/slave0.txt QuickSort 4
Client断开连接: /127.0.0.1:8881
Server建立连接：/127.0.0.1:62717
开始发送文件：./data/send/slave0.txt
文件发送结束：./data/send/slave0.txt
发送over
Server断开连接：/127.0.0.1:62717
程序用时：20947ms...
```

结果文件
```
-9999539987041744849471467124833727926741576613196160623043045674892853683817253184302040477042433650
-9998719856969091763391284150691390331622663143997330385755626480979236019314666230797164171656489883
-9998183474234380117894796514797453594223794144527483187399476168539335746957792233589784800676935209
-9997664471336162490184101697201950459874668371639742357352757368427316468445363442448358585761007999
-9997115258498567686577029270386792455885400440122100574461286508252816255430395790726912948039009296
-9996644360158054260186678186920079243096878175397463221646723458380511719103434088896273829959205987
-9995277383712620915052185215396610332556129220431451875339577933101742323914690024822634986641395148
-9994813554639515700242993274761972767688538148974244950293011630152729114042821930141050973095205444
-9994529355821654576763019925489853622534217847269219967616739487555750998882198129571566647478023216
-9993989736251872190369534755757173861478912993745466763180202810296460381396944431997319844810135843
...
9997759128813602771953983350717530175054238812974237406115722878822234319863560179876405135486204941
9998915513902154456781982903560118734345266039507621773730278504407390728990621244017039141095447306
9999459674546549508124878853496420271473125240862724406873522703950192426270703697961948508591845630
```

#### 4.10.2.3 slave1
执行日志
```
slave.name=slave1
Client建立连接：/127.0.0.1:8882
写文件：./data/receive/file1.txt
写文件结束： ./data/receive/file1.txt
执行命令：./Runner ./data/receive/file1.txt ./data/send/slave1.txt QuickSort 4
执行完成：./Runner ./data/receive/file1.txt ./data/send/slave1.txt QuickSort 4
Client断开连接: /127.0.0.1:8882
Server建立连接：/127.0.0.1:62716
开始发送文件：./data/send/slave1.txt
文件发送结束：./data/send/slave1.txt
发送over
Server断开连接：/127.0.0.1:62716
程序用时：18707ms...
```

结果文件
```
-9999529570811718921731412260328048908997679784608504245014077744742456841552549161792677318672782191
-9998891789754927587873763939133832908943894395821478542929569046846435746219986450307709817313878518
-9998211382558841423769448076290564059210969372282952886037898124372426956198527418298763181842293771
-9997213227615424400693288586105910097021930990669123353355054773511045087688939182524960918033253438
-9996860115182332520792748630241550486689623354556855574836303607921056427214795829018223851792622312
-9996388150935826594710406983578817651780761621286276980099171372139377839238923276631797876734259568
-9996149111276453227014863301213977543842600059177958631015795329236651391364354813024387930065786230
-9995974015093643300749181865696070057068301494559228577482458323310156194022883536461042621886283103
-9995694196332734785756947356261620058912604413226288284532343738201162982099526530351505105699901241
-9995366564882588283229304036702635134833621782335499913730683267554535585366115299523121420061877424
...
9998954645467690548940354927753243329255209141239514775818719504606388589462596550192962359671475345
9999623834249099941066974090890933891106643750217096809084822386555647414189344926394667498199799424
9999936731149501119753462444867274409151314153349020686649977384297984274535984111238568727746685510
```

### 4.10.3 程序结构
程序的运行基于配置文件run.properties，master配置文件如下：
```
mode=master
master.ip=127.0.0.1
master.slave0.port=8881
master.slave1.port=8882
data.generate.process=./generate
data.generate.rows=10000
data.send.path=./data/send/
data.receive.path=./data/receive/
data.sort.process=./Runner
data.sort.type=QuickSort
data.merge.file=./data/result.txt

slave.amount=2
slave.name=slave1
slave.thread.amount=3

slave0.ip=127.0.0.1
slave0.port=8081
slave0.receive.file=./data/receive/file0.txt
slave0.send.file=./data/send/slave0.txt

slave1.ip=127.0.0.1
slave1.port=8082
slave1.receive.file=./data/receive/file1.txt
slave1.send.file=./data/send/slave1.txt
```

目录结构
```
cluster
├── Runner
├── cluster.jar
├── data
│   ├── receive
│   │   ├── slave0.txt
│   │   └── slave1.txt
│   ├── result.txt
│   └── send
│       ├── file0.txt
│       └── file1.txt
├── generate
└── run.properties
```
Runner和generate为C++编译后的可执行文件。  
cluster.jar为java编译后的可执行jar。  
data文件夹下为进行发送和传输的文件。  
run.properties为配置文件。  

### 4.10.4 总结
分布式排序的难点在于进程之间的同步。程序开发中涉及使用TCP文件传输，需要先启动Server，之后启动client进行连接。在Java调用C++程序时也需要等待C++程序执行完成后再执行下一步。此程序有很多的问题，比如进程之间的同步不灵活，没有容错机制等。

当前成熟的分布式计算框架有Hadoop，Spark，Flink等，他们通常有以下的核心功能和组件：
一致性服务，比如通常使用Zookeeper，它可以提供节点之间的感知，命名空间管理等。  
容错机制，通常有HA机制，以及更进一步的联邦机制。  
调度及资源管理，Hadood有Yarn。  
分布式文件系统，Hadoop有HDFS。
流式计算，Spark Streaming, Flink Streaming等。